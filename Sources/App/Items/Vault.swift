//
//  Vault.swift
//  App
//
//  Created by Ido Constantine on 28/03/2018.
//

import Foundation
import TrashBoat
import Pelican

/**
Contains the valuables that are primed for theivin' and the currently available roles.

Is also a route, and allows players who are in front of it to view its contents and take something from it.
*/
class Vault: Route {
	
	typealias VaultResult = (String, InlineResultArticle)
	
	// STATE
	/// The roles currently available.
	var roles = Inventory()
	
	/// The amount of opals and other valuables currently available
	var valuables = PointManager()
	
	
	// ROUTING
	/// The player currently able to view and modify the vault.
	var currentViewer: Player?
	
	/// The inline key used to view the vault.  This has to be used in conjunction with a PlayerRoute.
	var inlineKey = MarkupInlineKey(fromCallbackData: "View Vault", text: "View Vault")
	
	
	// ROUTE CONTENTS + CHECKS
	/// If we need to setup a Message route to listen for a response, this is the closure we should call once a result is received.
	var next: ((VaultResult) -> ())?
	
	/// The cards generated by a new request.  Will be nil if the request was reset.
	var generatedOptions: [String: InlineResultArticle]?
	
	
	
	init() { }
	
	/**
	Clears all current roles and valuables available, and populates the vault with new ones.
	*/
	func fillVault(roles: Inventory, valuables: PointManager) {
		clear()
		self.roles = roles
		self.valuables = valuables
		self.roles.inlineCardTitle = "$name ($count left)"
	}
	
	/**
	Clears the vault of all roles and valuables.
	*/
	func clear() {
		self.roles.clearAll()
		//self.valuables
	}
	
	/**
	Defines a new player as the viewer of the vault, setting up their routes to be able to see the vault.
	*/
	func newRequest(newViewer: Player, next: (() -> ())? ) {
		
		// Set the current viewer
		currentViewer = newViewer
		
		var generatedCards: [String: InlineResultArticle] = [:]
		
		// If this is just for the kingpin, we just need to get some cards and give them to him with no routing.
		if newViewer.role?.definition == .kingpin {
			generatedCards = generateKingpinVaultView()
			
		}
		
		// If it's for anyone else, we need to generate a complex set of cards with labels and message routing.
		else {
			generatedCards = generateVaultView()
		}
		
	}
	
	/**
	Handle text requests to find a valid response.
	*/
	override func handle(_ update: Update) -> Bool {
		
		// Validate source
		if currentViewer == nil {
			print("\(#line) \(#function) - Vault route set, but no viewer present.")
			return false
		}
		
		if generatedOptions == nil {
			print("\(#line) \(#function) - Vault route set, but no options available.")
			return false
		}
		
		if update.id != currentViewer?.id { return false }
		if update.content == "" { return false }
		
		// Validate against current cards
		for card in generatedOptions! {
			guard let content = card.value.content?.base as? InputMessageContent_Text else {
				print("\(#line) \(#function) - Card content downcast failed during Vault handling.")
			}
			
			// Find entity that matches generated card signature
			if update.content == content.text {
				
				// Remove viewer powers pre-emptively
				currentViewer = nil
				
				// Remove the item from the valuables or roles list.
				
				// Trigger a closure if one is available to let an external event handle the result.
				next?(card.key, card.value)
				
			}
			
			
		}
		
		
		
		
		
		
		
		
		
	}
	
	
	/**
	Generates a list of potential selections someone can make while visiting the Vault.
	
	- warning: Do not use this for the Kingpin, as this list includes selections for taking certain quantities of Opals.
	*/
	func generateVaultView() -> [String: InlineResultArticle] {
		
		// Create an id counter and result dictionary
		var id = 1
		var cardSet: [String: InlineResultArticle] = [:]
		
		// Get the list of items available from the inventory.
		guard let roleCards = roles.getInlineCards(forType: KingpinRoles.type) else {
			print("\(#line) \(#function) - Role Cards Couldnt Be Found! D:")
			return [:]
		}
		
		// Get the item info and link it to the results
		var itemInfo = roles.getItemInfo(forType: KingpinRoles.type.name)!
		for (i, card) in roleCards.enumerated() {
			card.tgID = "\(id)"
			id += 1
			cardSet[itemInfo[i].name] = card
		}
		
		// Generate a list of choices when taking opals.
		let thiefRole = KingpinRoles.thief
		let opalCount = valuables[KingpinDefault.opal]
		let opalCards: [InlineResultArticle] = []
		
		let opalMax = max(min(5, opalCount), 0)
		for i in 1...opalMax {
			let newOpalCard = InlineResultArticle(id: "\(id)",
																						title: "Take \(i) ðŸ’Ž Opals (\(opalCount) left)",
																						description: KingpinRoles.thief.description,
																						contents: "",
																						markup: nil)
			cardSet["opal_\(i)"] = newOpalCard
			id += 1
		}
		
		
		// Replace the contents with a series of unique characters to keep the choice a secret.
		let anonymisedCardSet = anonymiser(options: cardSet)
		return anonymisedCardSet
		
	}
	
	/**
	Generates a simpler list of the current vault contents for the kingpin to inspect.
	*/
	func generateKingpinVaultView() -> [String: InlineResultArticle] {
	
		// Create an id counter and result dictionary
		var id = 1
		var cardSet: [String: InlineResultArticle] = [:]
		
		// Get the list of items available from the inventory.
		guard let roleCards = roles.getInlineCards(forType: KingpinRoles.type) else {
			print("\(#line) \(#function) - Role Cards Couldnt Be Found! D:")
			return [:]
		}
		
		// Get the item info and link it to the results
		var itemInfo = roles.getItemInfo(forType: KingpinRoles.type.name)!
		for (i, card) in roleCards.enumerated() {
			card.tgID = "\(id)"
			id += 1
			cardSet[itemInfo[i].name] = card
		}
		
		// Generate the total number of opals left as a card.
		let opalCount = valuables[KingpinDefault.opal]
		let newOpalCard = InlineResultArticle(id: "\(id)",
																					title: "\(opalCount) ðŸ’Ž Opals.",
			description: KingpinRoles.thief.description,
			contents: "",
			markup: nil)
		
		cardSet["opals"] = newOpalCard
		
	}
	
	/**
	Anonymises inline result contents with a unique code.
	*/
	func anonymiser(options: [String: InlineResultArticle]) -> [String: InlineResultArticle] {
		
		let glyphs = ["o", "-", "|", "â€¢"]
		var codes: [String] = []
		var results: [String: InlineResultArticle] = [:]
		
		for (optionIndex, optionSet) in options.enumerated() {
			let optionName = optionSet.key
			let optionValue = optionSet.value
			
			var newCode = glyphs.randomSelection(length: 16)!.joined()
			
			// Shuffle until we have a unique sequence.
			while codes.contains(newCode) == true {
				newCode = glyphs.randomSelection(length: 16)!.joined()
			}
			
			// Build the card and add the sequence to the list.
			codes.append(newCode)
			newOptionArray.append(InlineResultArticle(id: optionValue.tgID,
																								title: optionValue.title,
																								description: optionValue.description ?? "",
																								contents: newCode,
																								markup: nil))
			
			results[optionName] = optionValue
		}
		
		return results
	}
	
}
