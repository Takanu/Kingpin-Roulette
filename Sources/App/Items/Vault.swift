//
//  Vault.swift
//  App
//
//  Created by Ido Constantine on 28/03/2018.
//

import Foundation
import TrashBoat
import Pelican

/**
Contains the valuables that are primed for theivin' and the currently available roles.

Is also a route, and allows players who are in front of it to view its contents and take something from it.
*/
class Vault: Route {
	
	/// Defines a generated card and an item that it represents.
	typealias VaultResult = (item: ItemRepresentible?, card: InlineResultArticle)
	
	// STATE
	/// The roles currently available.
	var roles = Inventory()
	
	/// The amount of opals and other valuables currently available
	var valuables = PointManager()
	
	
	// ROUTING
	/// The player currently able to view and modify the vault.
	var currentViewer: Player?
	
	/// The inline key used to view the vault.  This has to be used in conjunction with a PlayerRoute.
	static var inlineKey = MarkupInlineKey(fromInlineQueryCurrent: "View Vault", text: "View Vault")
	
	
	// ROUTE CONTENTS + CHECKS
	/// If we need to setup a Message route to listen for a response, this is the closure we should call once a result is received.
	var next: ((ItemRepresentible) -> ())?
	
	/// The cards generated by a new request.  Will be nil if the request was reset.
	var vaultDisplay: [VaultResult]?
	
	
	// ERROR HANDLING
	var errorHandler: (Error) -> ()
	
	
	init(errorHandler: @escaping (Error) -> ()) {
		
		self.errorHandler = errorHandler
		
		super.init(name: "vault_message", action: {P in return true})
		self.roles.inlineCardTitle = "$name ($count left)"
		self.enabled = false
		
	}
	
	/**
	Defines a new player as the viewer of the vault, setting up their routes to be able to see the vault.
	*/
	func newRequest(newViewer: Player, includeOpals: Bool, next: ((ItemRepresentible) -> ())? ) {
		
		resetRequest()
		
		// Set the current viewer
		currentViewer = newViewer
		
		var vaultContents: [VaultResult] = []
		
		// If this is just for the kingpin, we just need to get some cards and give them to him with no routing.
		if newViewer.role?.definition == .kingpin {
			vaultContents = generateKingpinVaultView(includeOpals: includeOpals)
			
		}
		
		// If it's for anyone else, we need to generate a set of cards but also open message routing.
		else {
			vaultContents = generateVaultView(includeOpals: includeOpals)
			
		}
		
		// Set the cards to the Vault and player, and enable routing.
		currentViewer!.inlineVaultCards = vaultContents.map { $0.card }
		self.vaultDisplay = vaultContents
		self.next = next
		
		// Enable the route for operation only if the kingpin isn't the one viewing it.
		if newViewer.role?.definition != .kingpin {
			self.enabled = true
		}
		
	}
	
	/**
	Handle text requests to find a valid response.
	*/
	override func handle(_ update: Update) -> Bool {
		
		// Validate source
		if currentViewer == nil {
			print("\(#line) \(#function) - Vault route set, but no viewer present.")
			return false
		}
		
		if vaultDisplay == nil {
			print("\(#line) \(#function) - Vault route set, but no options available.")
			return false
		}
		
		if update.from!.tgID != currentViewer?.id { return false }
		if update.content == "" { return false }
		
		// Validate against current cards
		for option in vaultDisplay! {
			let card = option.card
			
			guard let content = card.content?.base as? InputMessageContent_Text else {
				errorHandler(KingpinError.cardContentDowncastFailed)
				return false
			}
			
			// Find entity that matches generated card signature
			if update.content == content.text {
				
				if option.item != nil {
					next?(option.item!)
				}
				
				return true
			}
		}
		
		return false
	}
	
	
	/**
	Generates a list of potential selections someone can make while visiting the Vault.
	
	- warning: Do not use this for the Kingpin, as this list includes selections for taking certain quantities of Opals.
	*/
	func generateVaultView(includeOpals: Bool) -> [VaultResult] {
		
		// Create an id counter and result dictionary
		var id = 1
		var cardSet: [VaultResult] = []
		
		
		///////////////////
		// INVENTORY ITEMS
		
		if let roleCards = roles.getInlineCards(forType: KingpinRoles.type) {
			
			var roleItems = roles.getItemCopies(forType: KingpinRoles.type.name)!
			for (i, card) in roleCards.enumerated() {
        var newCard = card
				newCard.tgID = "\(id)"
				id += 1
				cardSet.append((roleItems[i], newCard))
			}
		}
		
		
		////////////////////
		// OPALS
		
		// Generate a list of choices when taking opals.
		if includeOpals == true {
			
			guard let opalCount = valuables[KingpinDefault.opal] else {
				errorHandler(KingpinError.noOpals)
				return []
			}
			
			// Work out what the maximum number of opals the player can pick is.
			let opalMax = max(min(KingpinDefault.maxOpalTheft, opalCount.int), 0)
			
			if opalMax > 0 {
				for i in 1...opalMax {
					
          let opalUnit = OpalUnit(value: .int(i))
          var newOpalCard = opalUnit.getInlineCard()
          newOpalCard.title = "Steal \(i) ðŸ’Ž Opals (\(opalCount.int) left)"
          newOpalCard.description = KingpinRoles.thief.description
          
					cardSet.append((opalUnit, newOpalCard))
					id += 1
				}
			}
		}
		
		// If no cards are in the set, we need to report an issue.
		if cardSet.count == 0 {
			errorHandler(KingpinError.noCards)
		}
		
		
		// Replace the contents with a series of unique characters to keep the choice a secret.
		let anonymisedCardSet = anonymiser(options: cardSet)
		
		return anonymisedCardSet
		
	}
	
	/**
	Generates a simpler list of the current vault contents for the kingpin to inspect.
	*/
	func generateKingpinVaultView(includeOpals: Bool) -> [VaultResult] {
	
		// Create an id counter and result dictionary
		var id = 1
		var cardSet: [VaultResult] = []
		
		////////////////////
		// INVENTORY ITEMS
		
		if let roleCards = roles.getInlineCards(forType: KingpinRoles.type) {
			
			// Get the item info and link it to the results
			var itemInfo = roles.getItemCopies(forType: KingpinRoles.type.name)!
			for (i, card) in roleCards.enumerated() {
        var newCard = card
				newCard.tgID = "\(id)"
				id += 1
				cardSet.append((itemInfo[i], newCard))
			}
		}
		
		else {
			let noItemCard = InlineResultArticle(id: "\(id)",
																					 title: "No roles are left in the vault.",
																					 description: "(ï½¡â€¢Ìï¸¿â€¢Ì€ï½¡)",
																					 contents: KingpinDefault.fakeInlineContentMsg,
																					 markup: nil)
			cardSet.append((nil, noItemCard))
			id += 1
		}
			
		
		
		////////////////////
		// OPALS
		
		if includeOpals == true {
			
			guard let opalCount = valuables[KingpinDefault.opal] else {
				errorHandler(KingpinError.noOpals)
				return []
			}
			
			let opalUnit = OpalUnit(value: .int(opalCount.int))
      let newOpalCard = opalUnit.getInlineCard()
			
			// Return the new set.
			cardSet.append((opalUnit, newOpalCard))
		}
		
			
		else {
			let noOpalCard = InlineResultArticle(id: "\(id)",
																					 title: "No Opals are left in the vault.",
																					 description: "â”»â”â”» ï¸µãƒ½(`Ð”Â´)ï¾‰ï¸µ â”»â”â”»",
																					 contents: KingpinDefault.fakeInlineContentMsg,
																					 markup: nil)
			cardSet.append((nil, noOpalCard))
			id += 1
		}
		
		
		return cardSet
		
	}
	
	/**
	Anonymises inline result contents with a unique code.
	*/
	func anonymiser(options: [VaultResult]) -> [VaultResult] {
		
		let glyphs = ["o", "-", "|", "â€¢"]
		var codes: [String] = []
		var results: [VaultResult] = []
		
		for (_, optionSet) in options.enumerated() {
			let optionItem = optionSet.item
			let optionCard = optionSet.card
			
			var newCode = glyphs.randomSelection(length: 16)!.joined()
			
			// Shuffle until we have a unique sequence.
			while codes.contains(newCode) == true {
				newCode = glyphs.randomSelection(length: 16)!.joined()
			}
			
			// Build the card and add the sequence to the list.
			codes.append(newCode)
			let newCard = InlineResultArticle(id: optionCard.tgID,
																					title: optionCard.title,
																					description: optionCard.description ?? "",
																					contents: newCode,
																					markup: nil)
			
			
			results.append((optionItem, newCard))
		}
		
		return results
	}
	
	/**
	Resets the request, disabling vault view from the player and resetting the Vault state.
	*/
	func resetRequest() {
		
		currentViewer?.inlineVaultCards = []
		currentViewer = nil
		next = nil
		vaultDisplay = nil
		
		self.enabled = false
	}
	
}
